package ChatCommand

import LinkedList
import HashMap
import ErrorHandling


public function player.enableChatCommand(ChatCommand command)
    command.enableForPlayers(this)

public function player.disableChatCommand(ChatCommand command)
    command.disableForPlayers(this)
    
    

public class ChatCommand extends Command

    protected static let commandMap = new IterableMap<string, thistype>
    private static let commandTrigger = CreateTrigger()
    
    private boolean array[24] enabledPlayers
    private string command = ""

    /** Constructs a new chat command, which will trigger from the given
        string parameter. */
    construct(string command)
        super(command)

        if( commandMap.has(command) )
            commandError("That chat command has already been created")

        this.command = command
        commandMap.put(command, this)

        // Setup trigger
        for i=0 to 23  
            enabledPlayers[i] = true
            commandTrigger.registerPlayerChatEvent(Player(i), command, false)
        commandTrigger.addAction( function chatTriggerAction )

        disableForAllPlayers()

    function enableForPlayers( vararg player players )
        for p in players
            enabledPlayers[p.getId()] = true

    function disableForPlayers( vararg player players )
        for p in players
            enabledPlayers[p.getId()] = false
        
    function disableForAllPlayers()
        for i=0 to 23  
            enabledPlayers[i] = false

    function enableForAllPlayers()
        for i=0 to 23  
            enabledPlayers[i] = true


    
        

//================================================================================================================================================================================================



/** Enum to represent the type of an argument. null == NONE */
enum ArgumentType
    NONE
    INT
    REAL
    STRING

function ArgumentType.toString() returns string
    switch this
        case NONE
            return "NONE"
        case INT
            return "INT"
        case REAL
            return "REAL"
        case STRING
            return "STRING"
    
interface DefaultAction
    function run(player whichPlayer, ArgumentList arguments, OptionList options)

enum Error
    NONE
    WRONG_OPTION_ARG_TYPE
    MISSING_OPTION_ARG
    WRONG_ARG_TYPE
    UNKNOWN_OPTION
    MISSING_ARGUMENT
    UNKNOWN_SUB_COMMAND
    MISSING_SUB_COMMAND

function Error.toString() returns string
    switch this
        case NONE
            return "NONE"
        case MISSING_ARGUMENT
            return "MISSING_ARGUMENT"
        case WRONG_ARG_TYPE
            return "WRONG_ARG_TYPE"
        case MISSING_OPTION_ARG
            return "MISSING_OPTION_ARG"
        case WRONG_OPTION_ARG_TYPE
            return "WRONG_OPTION_ARG_TYPE"
        case UNKNOWN_SUB_COMMAND
            return "WRONG_SUB_COMMAND"
        default
            return "UNKNOWN"

interface CommandErrorCallback
    function run( player p, string commandStack )


class Argument
    bool isList
    ArgumentType argType

    construct(ArgumentType argType, bool list)
        this.argType = argType
        this.isList = list
        
class Option
    string label
    ArgumentType argType
    string defaultValue

    construct( string label, ArgumentType argType, string defaultValue )
        this.label = label
        this.argType = argType
        this.defaultValue = defaultValue


var error_Type = Error.NONE
var error_Option = ""
var error_ChatMessage = ""
var error_WrongInput = "" // The wrong input (i.e. when entered wrong sub command)
var error_ExpectedType = ArgumentType.NONE

function resetErrorData()
    error_Type = Error.NONE
    error_Option = ""
    error_ChatMessage = ""
    error_ExpectedType = ArgumentType.NONE
    
tuple errorData(
    Error error, string wrongInput,
    string fullInput,
    string option,
    ArgumentType expectedType)

class Command

    private static let defaultErrorCallbacks = new IterableMap<Error, CommandErrorCallback>
    private static var errorData = errorData(Error.NONE, "", "", "", ArgumentType.NONE)

    protected let subCommands = new IterableMap<string, thistype>
    private string command
    protected Command parent = null
    protected DefaultAction action = null
    private ArgumentType argumentType = NONE
    private boolean argumentRequired = false

    protected let arguments = new LinkedList<Argument>
    protected let options = new IterableMap<string, Option>

    private let errorCallbacks = new IterableMap<Error, CommandErrorCallback>


    construct(string command)
        if( command == "" )
            commandError("Command cannot be null")

        if( command.contains(" ") )
            commandError("Command cannot contain spaces")

        if( defaultErrorCallbacks.size() == 0)
            //defaultErrorCallbacks.put(Error.NO_DEFAULT, (p, stack) -> p.print("Missing sub command for command '" + stack + "'" )) 
            //defaultErrorCallbacks.put(Error.WRONG_TYPE_INT, (p, stack) -> p.print("Wrong argument type (requires integer) for command '" + stack + "'" )) 
            //defaultErrorCallbacks.put(Error.WRONG_TYPE_REAL, (p, stack) -> p.print("Wrong argument type (requires real) for command '" + stack + "'" )) 
            defaultErrorCallbacks.put(Error.MISSING_ARGUMENT, (p, stack) -> p.print("Argument required for command '" + stack + "'" )) 
            defaultErrorCallbacks.put(Error.UNKNOWN_SUB_COMMAND, (p, stack) -> p.print("Wrong sub command for command '" + stack + "'" )) 
                
        for errorType in defaultErrorCallbacks
            errorCallbacks.put(errorType, defaultErrorCallbacks.get(errorType) )

        this.command = command

    /* Formats an error meant for the map creator, NOT the map player. I.e. used for
        missing settings, such as missing 'action' */
    function commandError(string error)
        error("ChatCommand: {0} (in command '{1}')".format(error, getFullCommand()))

    static function setDefaultErrorCallback(Error errorType, CommandErrorCallback callback)
        if( defaultErrorCallbacks.has(errorType) )
            defaultErrorCallbacks.remove(errorType)
        defaultErrorCallbacks.put(errorType, callback)

    function setErrorCallback(Error errorType, CommandErrorCallback callback)
        if( errorCallbacks.has(errorType) )
            errorCallbacks.remove(errorType)
        errorCallbacks.put(errorType, callback)
        
    function setAction( DefaultAction action )
        this.action = action


    function addSubCommand(string command) returns Command
        if( subCommands.has(command) )
            commandError("Sub command '{0}' has already been created".format(command))
        if( action != null )
            commandError("Cannot add sub command {0} to command with action".format(command)) 
        if( arguments.size() > 0 )
            commandError("Cannot add sub command {0} to command with arguments".format(command)) 
        if( options.size() > 0  )
            commandError("Cannot add sub command {0} to command with options".format(command)) 

        let subCommand = new Command(command)
        subCommand.parent = this
        subCommands.put(command, subCommand)
    
        for key in errorCallbacks
            subCommand.setErrorCallback(key, errorCallbacks.get(key))

        return subCommand

    /** Returns the full command (with parent commands) */
    function getFullCommand() returns string
        var command = this.command
        var parent = this.parent
        while(parent != null)
            command = parent.command + " " + command
            parent = parent.parent
        return command
    
    function addArgument( ArgumentType argumentType)
        addArgument(argumentType, false)

    function addListArgument( ArgumentType argumentType)
        addArgument(argumentType, true)

    private function addArgument( ArgumentType argumentType, boolean isList )
        if( subCommands.size() > 0  )
            commandError("Cannot add argument to command with sub commands")
        if( arguments.peek() != null and arguments.peek().isList )
            commandError("No arguments may preceed list argument")

        arguments.add( new Argument(argumentType, isList ))

    function addOptionSwitch( string option )
        addOption(option, ArgumentType.NONE, "")

    function addOptionReal( string option, real defaultValue )
        addOption(option, ArgumentType.REAL, defaultValue.toString() )

    function addOptionString( string option, string defaultValue )
        addOption(option, ArgumentType.STRING, defaultValue )

    function addOptionInt( string option, int defaultValue )
        addOption(option, ArgumentType.INT, defaultValue.toString())

    
    private function addOption( string option, ArgumentType argumentType, string defaultValue )
        if( subCommands.size() > 0  )
            commandError("Cannot add option {0} to command with sub commands".format(option) )
        
        if( options.has(option) )
            commandError("Option {0} already exists".format(option))

        options.put(option, new Option(option, argumentType, defaultValue))





// Global lists used for all incoming commands
let argumentList = new ArgumentList()
let optionList = new OptionList() 

function resetData()
    argumentList.clear()
    optionList.clear()
    resetErrorData()

function chatTriggerAction()
    commandEntered(GetTriggerPlayer(), GetEventPlayerChatString())
    
function commandEntered(player enteringPlayer, string enteredCommand) returns bool
    let words = splitWords(enteredCommand)
    let rootCommand = words.dequeue()
    var success = true

    if( ChatCommand.commandMap.has(rootCommand) )
        success = runCommand(enteringPlayer, ChatCommand.commandMap.get(rootCommand), words)
        if( not success )
            //TODO: Run Error Callback
            
    destroy words
    return success



function runCommand( player enteringPlayer, Command originCommand, LinkedList<string> inputs ) returns boolean
    resetData()

    // Command with action (with no sub commands)
    var command = originCommand 

    // Find command
    while( command.subCommands.size() > 0 )
        let input = inputs.dequeue()
        if( input == null )
            error_Type = MISSING_SUB_COMMAND
            return false
        command = command.subCommands.get(input)
        if( command == null )
            error_Type = UNKNOWN_SUB_COMMAND
            error_WrongInput = input
            return false

    // Checking Action
    if( command.action == null )
        command.commandError("No subcommand or default action has been given")
        return false

    var success = false

    // Interpreet Arguments
    success = interpretInputArguments(command, inputs)
    if( not success )
        return false

    // Interpreet Arguments
    success = interpretInputOptions(command, inputs)
    if( not success )
        return false

    // Run Action
    command.action.run( enteringPlayer, argumentList, optionList )
    
    // Clean up
    return true



    
function interpretInputArguments( Command command, LinkedList<string> inputs ) returns bool
    var argList = new ArgumentList()
    
    for argument in command.arguments
        if( argument.isList )
        // List Argument
            var elementCount = 0
            var input = inputs.getFirst()
            while( input != "" and not command.options.has(input) )
                if( (argument.argType == ArgumentType.INT and not input.isInt()) or (argument.argType == ArgumentType.REAL and not input.isReal()) )
                    error_Type = WRONG_ARG_TYPE
                    error_ExpectedType = argument.argType
                    return false
                argList.addArgument(argument.argType, inputs.dequeue())
                elementCount++
                input = inputs.getFirst()

            if( elementCount == 0 )
                error_Type = MISSING_ARGUMENT
                return false

        else
        // Single Argument
            let input = inputs.getFirst()
            if( input == "" )
                error_Type = MISSING_ARGUMENT
                return false
            else
                var correctArg = true
                if( argument.argType == ArgumentType.INT and not input.isInt() )
                    correctArg = false
                if( argument.argType == ArgumentType.REAL and not input.isReal() )
                    correctArg = false

                if( correctArg )
                    argList.addArgument(argument.argType, inputs.dequeue() )
                else
                    error_Type = WRONG_ARG_TYPE
                    error_ExpectedType = argument.argType
                    return false            
    return true




function interpretInputOptions(Command command, LinkedList<string> inputs) returns bool
    let options = command.options
    
    for word in inputs

        if( options.has(word) )
        // Switch Option
            let option = options.get(word)
            if( option.argType == NONE )
                optionList.add(option.label, "")
            else
                error_Type = MISSING_OPTION_ARG
                error_ExpectedType = option.argType
                return false
            
        else if( word.length() > 2 and word.contains("=") )
        // Value Option
                    
            var optionLabel = word.substring(0, word.indexOf("="))
            var optionValue = word.substring(word.indexOf("=")+1, word.length())
            var option = options.get(optionLabel)

            if( option == null )
                error_Type = UNKNOWN_OPTION
                return false
            
            var correctType = true
            if( option.argType == NONE or (option.argType == ArgumentType.INT and not optionValue.isInt()) or (option.argType == ArgumentType.REAL and not optionValue.isReal()) )
                correctType = false

            if( not correctType)
                error_Type = WRONG_OPTION_ARG_TYPE
                error_ExpectedType = option.argType
                return false
            optionList.add(optionLabel, optionValue)

        else
            error_Type = UNKNOWN_OPTION
            return false

    return true
                
    


        

class ArgumentList

    protected let values = new LinkedList<string>
    protected let types = new LinkedList<ArgumentType>
    protected Command command = null

    ondestroy
        destroy values
        destroy types

    function setCommand(Command command)
        this.command = command

    protected function addArgument(ArgumentType argType, string value)
        types.add(argType)
        values.add(value)

    function getInt() returns int
        if( types.dequeue() != ArgumentType.INT )
            command.commandError("Next argument is not an integer value")
        return values.dequeue().toInt()

    function getReal() returns real
        if( types.dequeue() != ArgumentType.REAL )
            command.commandError("Next argument is not a real value")
        return values.dequeue().toReal()

    function getString() returns string
        if( types.dequeue() != ArgumentType.STRING )
            command.commandError("Next argument is not a real value")
        return values.dequeue()

    function size() returns int
        return values.size()

    function hasNext() returns boolean
        return values.size() > 0

    protected function clear()
        values.clear()
        types.clear()
        command = null


class OptionList

    protected let values = new IterableMap<string, string>
    protected Command command

    ondestroy
        destroy values

    function setCommand(Command command)
        this.command = command
    
    function add( string option, string value )
        if(values.has(option))
            values.remove(option)
        values.put(option, value)

    private function getOption(string option) returns Option
        if( not command.options.has(option) )
            command.commandError("Cannot find option {0}".format(option))
        return command.options.get(option)

    function getInt(string option) returns int
        if( getOption(option).argType != INT )
            command.commandError("Option {0} is not an integer value".format(option))
        return values.has(option) ? values.get(option).toInt() : getOption(option).defaultValue.toInt()         

    function getReal(string option) returns real
        if( getOption(option).argType != REAL )
            command.commandError("Option {0} is not a real value".format(option))
        return values.has(option) ? values.get(option).toReal() : getOption(option).defaultValue.toReal()       

    function getString(string option) returns string
        if( getOption(option).argType != STRING )
            command.commandError("Option {0} is not a string value".format(option))
        return values.has(option) ? values.get(option) : getOption(option).defaultValue   
    
    function getBool(string option) returns bool
        if( getOption(option).argType != NONE )
            command.commandError("Option {0} is not a switch (boolean value)".format(option))
        return values.has(option) 
        
    protected function clear()
        values.flush()
        command = null
        


// Splits an input string (i.e. chat message) into words
function splitWords(string input) returns LinkedList<string>
    let words = new LinkedList<string>
    var buildString = ""
    var inQuoteSequence = false
    // Quote sequence may contain white space

    // Iteratae over all characters
    for c in input
        var completed = false
        
        if( c == "\"")
            // Entereing quote sequeence (string sequence
            // surrounded by quote - can include whitespace)
            if( inQuoteSequence )
                inQuoteSequence = false
                completed = true 
            else
                inQuoteSequence = true
        else if( c == " " and not inQuoteSequence)
            completed = true
        else
            buildString += c

        // Created a new word
        if( completed and buildString != "" )
            words.add(buildString)
            buildString = "" 
    
    if( buildString != "" )
        words.add(buildString)
    return words
        
        

// --------------------------------------------------------------------------------------------------------------------------
// Type Checking Methods 

/**
    Tests if the string is an integer.
    Special cases:
        - null -> false
        - "" -> false
        - 001 -> true
*/
function string.isInt() returns boolean
    if( this == null or this.length() == 0 )
        return false

    for c in this
        if( c != "0" and c != "-" and c.toInt() == 0)
            return false
    return true

/**
    Tests if the string is a real 
    Special cases:
        - null -> false
        - "" -> false
*/
function string.isReal() returns boolean
    if( this == null or this.length() == 0 )
        return false

    var foundDot = false
    for c in this
        if( c == ".")
            if( foundDot )
                return false
            foundDot = true
        else if ( c != "0" and c != "-" and c.toInt() == 0)
            return false
    return true


/* The argument type can be conisdered hierarchical:
        if the argument is an int, it's also a string and real
        if the argument is real, it's also a string
        the argument is always a string */
function string.getArgumentType() returns ArgumentType
    if( this.isInt() )
        return ArgumentType.INT
    if( this.isReal() )
        return ArgumentType.REAL
    return ArgumentType.STRING
        


// ==============================================================================================================================================
// DEBUGGING

let DEBUG_PACKAGE = false
        
init
    if( DEBUG_PACKAGE )

        // // Just a command for testing
        // let command = new ChatCommand("cmd")
        // ..setArgumentType(ArgumentType.INT, true) 
            
        // command.addSubCommand("sub1")
        // ..setArgumentType(ArgumentType.REAL, true)
        // ..setAction( (p, args) -> print("Sub 1, " + args.argsToString()) ) 

        // command.addSubCommand("sub2")
        // ..setArgumentType(ArgumentType.INT, true)
        // ..setAction( (p, args) -> print("Sub 2, " + args.argsToString()) ) 
    
        // command.addSubCommand("sub3")
        // ..setArgumentType(ArgumentType.INT, false)
        // ..setAction( (p, args) -> print("Sub 3, " + args.argsToString()) )         
        


function LinkedList<string>.argsToString() returns string
    var str = "Args{ "
    var first = true
    for arg in this
        if( not first) 
            str += ", "
        first = false
        str += arg
    str += "}"
    return str
         
    

// ==============================================================================================================================================
// UNIT TESTING    

// Type Checking test
@Test 
public function testTypeChecking()

    // Is Integer
    null.isInt().assertFalse()
    "".isInt().assertFalse()
    "a".isReal().assertFalse()
    "1a1".isInt().assertFalse()
    "a1".isInt().assertFalse()
    "1a".isInt().assertFalse()
    "1 1".isInt().assertFalse()

    "0.1".isInt().assertFalse()
    ".1".isInt().assertFalse()
    "1.".isInt().assertFalse()
    "001".isInt().assertTrue()
    "1345".isInt().assertTrue()
    "-1".isInt().assertTrue()

    // Is Real
    null.isReal().assertFalse()
    "".isReal().assertFalse()
    "a".isReal().assertFalse()
    "1a1".isReal().assertFalse()
    "a1".isReal().assertFalse()
    "1a".isReal().assertFalse()
    "1,1".isReal().assertFalse()
    "1.1.2".isReal().assertFalse()
    "1 1".isReal().assertFalse()

    "1".isReal().assertTrue()
    "10.".isReal().assertTrue()
    ".1".isReal().assertTrue()
    "0.1".isReal().assertTrue()
    "1.123".isReal().assertTrue()
    "-1".isReal().assertTrue()
    "-0.1".isReal().assertTrue()
    "-.1".isReal().assertTrue()


// Command String test
@Test
function commandStringTest()
    
    let testString = "hello world 123 \"quote string\" waddup yeah"
    let commandString = splitWords(testString)

    commandString.dequeue().assertEquals("hello")
    commandString.dequeue().assertEquals("world")
    commandString.dequeue().assertEquals("123")
    commandString.dequeue().assertEquals("quote string")
    commandString.dequeue().assertEquals("waddup")
    commandString.dequeue().assertEquals("yeah")

    commandString.dequeue().assertEquals("")

// ======================================================================================================================================================
// CHAT COMMAND TESTING 

// // Setup and additional test functions
// boolean defaultActionFired = false
// Error lastError = NONE
// LinkedList<string> lastArguments = null

// function ChatCommand.test(string msg, Error expectedError )
//     defaultActionFired = false
//     lastError = null

//     if(lastArguments != null)
//         destroy lastArguments
//     lastArguments = null

//     let arguments = new LinkedList<string>
//     let cmdString = new InputString(msg)
//     this.runCommand(Player(0), cmdString, arguments, cmdString.next())
    
//     // if( expectedError != lastError )
//     //     testFail( expectedError.toString() + " != "+lastError.toString())
    
//     if( expectedError != null )
//         assertTrue( not defaultActionFired )
//     else
//         assertTrue(defaultActionFired)


// function test_registerDefaultAction()
//     defaultActionFired = true

// function test_setLastError(Error error)
//     lastError = error

// function Command.test_addSubCommand(string commandString) returns Command
//     let command = this.addSubCommand(commandString)
//     ..test_setupCommand()
//     return command    

// function Command.test_setupCommand()
//     //this.setErrorCallback(Error.NO_DEFAULT, (p, s) -> test_setLastError(Error.NO_DEFAULT))
//     this.setErrorCallback(Error.UNKNOWN_SUB_COMMAND, (p, s) -> test_setLastError(Error.UNKNOWN_SUB_COMMAND))
//     this.setErrorCallback(Error.MISSING_ARGUMENT, (p, s) -> test_setLastError(Error.MISSING_ARGUMENT))
//     //this.setErrorCallback(Error.WRONG_TYPE_INT, (p, s) -> test_setLastError(Error.WRONG_TYPE_INT))
//     //this.setErrorCallback(Error.WRONG_TYPE_REAL, (p, s) -> test_setLastError(Error.WRONG_TYPE_REAL))


// function test_createCommand( string cmd ) returns ChatCommand
//     let command = new ChatCommand(cmd)
//     command.test_setupCommand()
//     return command

// function Command.test_setDefaultAction()
//     this.setAction() (player whichPlayer, LinkedList<string> arguments) ->
//         test_registerDefaultAction()
//         lastArguments = arguments
    
    

@Test
function chatCommandTest()

    
//     let command = test_createCommand("cmd")
//     ..setArgumentType(ArgumentType.INT, true)
//     ..test_setDefaultAction()

//     command.test("cmd", CommandError.ARGUMENT_REQUIRED)

//     command.test("cmd wrongarg", CommandError.WRONG_TYPE_INT)

//     command.test("cmd 10.2", CommandError.WRONG_TYPE_INT)

//     command.test("cmd 10", null) 

//     command.setArgumentType(ArgumentType.INT, false)

//     command.test("cmd", null) 

//     command.test("cmd wrongarg", CommandError.WRONG_TYPE_INT)

//     command.test("cmd 10.2", CommandError.WRONG_TYPE_INT)

//     command.test("cmd 12", null)
//     lastArguments.get(0).toInt().assertEquals(12)


// @Test
// function subcommandTest()
    
//     let command = test_createCommand("cmd")
//     ..setArgumentType(ArgumentType.STRING, false)
    
//     ..test_setDefaultAction()

//     command.test_addSubCommand("sub1")
//     ..test_setDefaultAction()

//     command.test("cmd sub1", null)

//     command.setArgumentType(ArgumentType.STRING, true)
    
//     command.test("cmd sub1", CommandError.ARGUMENT_REQUIRED)

//     command.test("cmd arg sub1", null)






//================================================================================================================================================================================================
// New Tests

function ArgumentType.assertEquals(ArgumentType expected)
    if this != expected
	    testFail("Expected <" + expected.toString() + ">, Actual <" + this.toString() + ">")

function Error.assertEquals(Error expected)
    if this != expected
	    testFail("Expected <" + expected.toString() + ">, Actual <" + this.toString() + ">")

public function assertNull<T>(T t)
	if t != null
		testFail("Assertion failed: Reference was not null.")





@Test
function subCommandTest()
    /* Test if sub commands are registered correctly, and correct errors
        are given  */
    var cmd = new ChatCommand("-root")
    cmd.addSubCommand("sub1")//.setAction( (p, args, opts) -> skip)
    cmd.addSubCommand("sub2")//.setAction( (p, args, opts) -> skip)

    // Testing correct calls
    assertTrue( commandEntered(null, "-root sub1") )
    error_Type.assertEquals( Error.NONE )
    
    assertTrue( commandEntered(null, "-root sub2") )
    error_Type.assertEquals( Error.NONE )

    // Testing wrong calls
    assertTrue( not commandEntered(null, "-root sub") )
    error_Type.assertEquals( Error.UNKNOWN_SUB_COMMAND )

    assertTrue( not commandEntered(null, "-root sub sub1") )
    error_Type.assertEquals( Error.UNKNOWN_SUB_COMMAND )
    
    assertTrue( commandEntered(null, "-root") )
    error_Type.assertEquals( Error.MISSING_SUB_COMMAND )



    
@Test
function optionEvaluationTest()

    let cmd = new Command("cmd")
    ..addOptionInt("o1", 10)
    ..addOptionReal("o2", 10.)
    ..addOptionString("o3", "hello")
    ..addOptionSwitch("o4")

    let input = new LinkedList<string>
    resetErrorData()
    optionList.clear()

    // All values correct
    input..clear()..add("o2=0.5", "o1=20", "o4", "o3=nothello" )
    assertTrue(interpretInputOptions(cmd, input))
    optionList.getInt("o1").assertEquals(20)
    optionList.getReal("o2").assertEquals(0.5)
    optionList.getString("o3").assertEquals("nothello")
    optionList.getBool("o4").assertTrue()

    // No values given (testing default values)
    input..clear()
    assertTrue(interpretInputOptions(cmd, input))
    optionList.getInt("o1").assertEquals(10)
    optionList.getReal("o2").assertEquals(10.)
    optionList.getString("o3").assertEquals("hello")
    optionList.getBool("o4").assertFalse()

    // Wrong option argument
    resetData()
    input..clear()..add("o2=0.5","o1=0.6")
    assertTrue(interpretInputOptions(cmd, input))
    error_Type.assertEquals(Error.WRONG_OPTION_ARG_TYPE)

    // Wrong argument for switch (should be none)
    resetData()
    input..clear()..add("o4=10")
    assertTrue(interpretInputOptions(cmd, input))
    error_Type.assertEquals(Error.WRONG_OPTION_ARG_TYPE)

    // Missing Argument Type
    resetData()
    input..clear()..add("o2")
    assertTrue(interpretInputOptions(cmd, input))
    error_Type.assertEquals(Error.MISSING_OPTION_ARG)

    // Double option
    resetData()
    input..clear()..add("o2=10", "o2=100")
    assertTrue(interpretInputOptions(cmd, input))
    optionList.getReal("o2").assertEquals(100)

    // Wrong option 1 
    resetData()
    input..clear()..add("o5=hello")
    assertTrue(interpretInputOptions(cmd, input))
    error_Type.assertEquals(Error.UNKNOWN_OPTION)

    // Wrong option 2
    resetData()
    input..clear()..add("thisisnotanoption")
    assertTrue(interpretInputOptions(cmd, input))
    error_Type.assertEquals(Error.UNKNOWN_OPTION)


@Test
function argumentEvaluationTest_Simple()
    
    let cmd = new Command("cmd")..addArgument( ArgumentType.INT )
    let inputs = new LinkedList<string>
    resetData()

    // Correct
    inputs.add("100")
    assertTrue(interpretInputArguments(cmd, inputs))
    argumentList.getInt().assertEquals(100)

    // Wrong Type
    inputs..clear()..add("hello")
    assertTrue(interpretInputArguments(cmd, inputs))
    assertTrue( error_Type == Error.WRONG_ARG_TYPE )
    assertTrue( error_ExpectedType == ArgumentType.INT)

    // Missing argument
    resetData()
    inputs.clear()
    assertTrue(interpretInputArguments(cmd, inputs))
    error_Type.assertEquals(Error.MISSING_ARGUMENT)
    

@Test
function argumentEvaluationTest_List()
    let cmd = new Command("cmd")..addListArgument( ArgumentType.INT )
    let inputs = new LinkedList<string>
    resetData()
    
    // Correct arguments
    inputs.add("100","200","300","400","500")
    assertTrue(interpretInputArguments(cmd, inputs))
    argumentList.getInt().assertEquals(100)
    argumentList.getInt().assertEquals(200)
    argumentList.getInt().assertEquals(300)
    argumentList.getInt().assertEquals(400)
    argumentList.getInt().assertEquals(500)

    // No arguments
    resetData()
    inputs.clear()
    assertTrue(interpretInputArguments(cmd, inputs))
    error_Type.assertEquals(Error.MISSING_ARGUMENT)

    // Wrong argument type
    resetData()
    inputs.clear()
    inputs.add("100", "200", "300", "hello")
    assertTrue(interpretInputArguments(cmd, inputs))
    error_Type.assertEquals(Error.WRONG_ARG_TYPE)
    

@Test
function argumentEvaluationTest_DoubleArgument()
    

    let cmd = new Command("cmd")
    ..addArgument(ArgumentType.INT )
    ..addArgument(ArgumentType.STRING )
    let inputs = new LinkedList<string>
    resetData()
    
    // Both args
    resetData()
    inputs..clear()..add("100","hello")
    assertTrue(interpretInputArguments(cmd, inputs))
    argumentList.getInt().assertEquals(100)
    argumentList.getString().assertEquals("hello")

    // No args
    resetData()
    inputs.clear()
    assertTrue(interpretInputArguments(cmd, inputs))
    error_Type.assertEquals(Error.MISSING_ARGUMENT)

    // Only first Arg
    resetData()
    inputs..clear()..add("100")
    assertTrue(interpretInputArguments(cmd, inputs))
    error_Type.assertEquals(Error.MISSING_ARGUMENT)

    // Only second arg (error since first is int and second is string)
    resetData()
    inputs..clear()..add("hello")
    assertTrue(interpretInputArguments(cmd, inputs))
    error_Type.assertEquals(Error.WRONG_ARG_TYPE)


    

    

    
    



