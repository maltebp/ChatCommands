package ChatCommand

import LinkedList
import HashMap
import ErrorHandling
import CC_WordSplitter
import CC_TypeChecking    
    

public class ChatCommand extends Command

    protected static let commandMap = new IterableMap<string, thistype>
    private static let commandTrigger = CreateTrigger()
    
    protected boolean array[24] enabledPlayers

    /** Constructs a new chat command, which will trigger from the given
        string parameter. */
    construct(string command)
        super(command)

        if( commandMap.has(command) )
            commandError("That chat command has already been created")

        this.command = command
        commandMap.put(command, this)

        // Setup trigger
        for i=0 to 23  
            enabledPlayers[i] = true
            commandTrigger.registerPlayerChatEvent(Player(i), command, false)
        commandTrigger.addAction( function chatTriggerAction )

        disableForAllPlayers()

    function enableForPlayers( vararg player players )
        for p in players
            enabledPlayers[p.getId()] = true

    function disableForPlayers( vararg player players )
        for p in players
            enabledPlayers[p.getId()] = false
        
    function disableForAllPlayers()
        for i=0 to 23  
            enabledPlayers[i] = false

    function enableForAllPlayers()
        for i=0 to 23  
            enabledPlayers[i] = true


    
        

//==============================================================================================================================================================================================
// COMMAND ARGUMENT

/** Enum to represent the type of an argument. null == NONE */
public enum ArgumentType
    NONE
    INT
    REAL
    STRING

public function ArgumentType.toString() returns string
    switch this
        case NONE
            return "NONE"
        case INT
            return "INT"
        case REAL
            return "REAL"
        case STRING
            return "STRING"
    


//================================================================================================================================================================================================
// COMMAND ERROR

/** Enum type to represent a type of error which may occur when
    running a command. */
public enum CommandError
    NONE
    UNKNOWN_SUB_COMMAND
    MISSING_SUB_COMMAND
    WRONG_ARG_TYPE
    MISSING_ARGUMENT
    UNKNOWN_OPTION
    WRONG_OPTION_ARG_TYPE
    MISSING_OPTION_ARG

/** Turns the CommandError into a string format. The resulting string
    is the same as its enum name (i.e. NONE -> "NONE") */
public function CommandError.toString() returns string
    switch this
        case NONE
            return "NONE"
        case MISSING_SUB_COMMAND
            return "MISSING_SUB_COMMAND"
        case MISSING_ARGUMENT
            return "MISSING_ARGUMENT"
        case WRONG_ARG_TYPE
            return "WRONG_ARG_TYPE"
        case UNKNOWN_OPTION
            return "UNKNOWN_OPTION"
        case MISSING_OPTION_ARG
            return "MISSING_OPTION_ARG"
        case WRONG_OPTION_ARG_TYPE
            return "WRONG_OPTION_ARG_TYPE"
        case UNKNOWN_SUB_COMMAND
            return "UNKNOWN_SUB_COMMAND"
        default
            return "UNKNOWN"

// Error Data
var lastErrorData = errorData(CommandError.NONE, "", "", "", ArgumentType.NONE)

/** Get tuple containing data about last occuring error. The data will reset
    when a new command is entered. */
public function getLastCommandError() returns errorData
    return lastErrorData

/** Tuple containing data about last error */
tuple errorData(
    CommandError error, // Type of the error
    string chatMessage, // Source chat message
    string option, // Option causing the error (if known)
    string wrongInput, // The wrong input
    ArgumentType expectedType // The expected type (argument type or option argument type)
)

/** Resets the error data to 'no error' */
function resetErrorData()
    lastErrorData.error = CommandError.NONE
    lastErrorData.option = ""
    lastErrorData.chatMessage = ""
    lastErrorData.wrongInput = ""
    lastErrorData.expectedType = ArgumentType.NONE



public interface CommandErrorCallback
    function run( player p, string commandStack )

public interface DefaultAction
    function run(player whichPlayer, ArgumentList arguments, OptionList options)


class Argument
    bool isList
    ArgumentType argType

    construct(ArgumentType argType, bool list)
        this.argType = argType
        this.isList = list
        
class Option
    string label
    ArgumentType argType
    string defaultValue

    construct( string label, ArgumentType argType, string defaultValue )
        this.label = label
        this.argType = argType
        this.defaultValue = defaultValue


class Command

    private static let defaultErrorCallbacks = new IterableMap<CommandError, CommandErrorCallback>

    protected let subCommands = new IterableMap<string, thistype>
    protected string command
    protected Command parent = null
    protected DefaultAction action = null

    protected let arguments = new LinkedList<Argument>
    protected let options = new IterableMap<string, Option>

    private let errorCallbacks = new IterableMap<CommandError, CommandErrorCallback>


    construct(string command)
        if( command == "" )
            commandError("Command cannot be null")

        if( command.contains(" ") )
            commandError("Command cannot contain spaces")

        if( defaultErrorCallbacks.size() == 0)
            //defaultErrorCallbacks.put(Error.NO_DEFAULT, (p, stack) -> p.print("Missing sub command for command '" + stack + "'" )) 
            //defaultErrorCallbacks.put(Error.WRONG_TYPE_INT, (p, stack) -> p.print("Wrong argument type (requires integer) for command '" + stack + "'" )) 
            //defaultErrorCallbacks.put(Error.WRONG_TYPE_REAL, (p, stack) -> p.print("Wrong argument type (requires real) for command '" + stack + "'" )) 
            defaultErrorCallbacks.put(CommandError.MISSING_ARGUMENT, (p, stack) -> p.print("Argument required for command '" + stack + "'" )) 
            defaultErrorCallbacks.put(CommandError.UNKNOWN_SUB_COMMAND, (p, stack) -> p.print("Wrong sub command for command '" + stack + "'" )) 
                
        for errorType in defaultErrorCallbacks
            errorCallbacks.put(errorType, defaultErrorCallbacks.get(errorType) )

        this.command = command

    /* Formats an error meant for the map creator, NOT the map player. I.e. used for
        missing settings, such as missing 'action' */
    protected function commandError(string error)
        error("ChatCommand: {0} (in command '{1}')".format(error, getFullCommand()))

    static function setDefaultErrorCallback(CommandError errorType, CommandErrorCallback callback)
        if( defaultErrorCallbacks.has(errorType) )
            defaultErrorCallbacks.remove(errorType)
        defaultErrorCallbacks.put(errorType, callback)

    function setErrorCallback(CommandError errorType, CommandErrorCallback callback)
        if( errorCallbacks.has(errorType) )
            errorCallbacks.remove(errorType)
        errorCallbacks.put(errorType, callback)
        
    function setAction( DefaultAction action )
        this.action = action

        
    /** Create and add a 'sub command' to the existing command. Adding the sub command 'sub' to the
        parent command 'parent' results in the total command for the sub command: 'parent sub'. */
    function addSubCommand(string command) returns Command
        if( subCommands.has(command) )
            commandError("Sub command '{0}' has already been created".format(command))
        if( action != null )
            commandError("Cannot add sub command {0} to command with action".format(command)) 
        if( arguments.size() > 0 )
            commandError("Cannot add sub command {0} to command with arguments".format(command)) 
        if( options.size() > 0  )
            commandError("Cannot add sub command {0} to command with options".format(command)) 

        let subCommand = new Command(command)
        subCommand.parent = this
        subCommands.put(command, subCommand)
    
        for key in errorCallbacks
            subCommand.setErrorCallback(key, errorCallbacks.get(key))

        return subCommand

    /** Returns the full command (with parent commands) */
    function getFullCommand() returns string
        var command = this.command
        var parent = this.parent
        while(parent != null)
            command = parent.command + " " + command
            parent = parent.parent
        return command
    
    function addArgument( ArgumentType argumentType)
        addArgument(argumentType, false)

    function addListArgument( ArgumentType argumentType)
        addArgument(argumentType, true)

    function addOptionSwitch( string option )
        addOption(option, ArgumentType.NONE, "")

    function addOptionReal( string option, real defaultValue )
        addOption(option, ArgumentType.REAL, defaultValue.toString() )

    function addOptionString( string option, string defaultValue )
        addOption(option, ArgumentType.STRING, defaultValue )

    function addOptionInt( string option, int defaultValue )
        addOption(option, ArgumentType.INT, defaultValue.toString())

    
    private function addArgument( ArgumentType argumentType, boolean isList )
        if( subCommands.size() > 0  )
            commandError("Cannot add argument to command with sub commands")
        if( arguments.peek() != null and arguments.peek().isList )
            commandError("No arguments may preceed list argument")

        arguments.add( new Argument(argumentType, isList ))

    private function addOption( string option, ArgumentType argumentType, string defaultValue )
        if( subCommands.size() > 0  )
            commandError("Cannot add option {0} to command with sub commands".format(option) )
        
        if( options.has(option) )
            commandError("Option {0} already exists".format(option))

        options.put(option, new Option(option, argumentType, defaultValue))





// Global lists used for all incoming commands
let argumentList = new ArgumentList()
let optionList = new OptionList() 

function resetData()
    argumentList.clear()
    optionList.clear()
    resetErrorData()

function chatTriggerAction()
    commandEntered(GetTriggerPlayer(), GetEventPlayerChatString())

function commandEntered(player enteringPlayer, string enteredCommand) returns bool
    let words = splitWords(enteredCommand)
    let rootCommand = words.dequeue()
    var success = true

    if( ChatCommand.commandMap.has(rootCommand) )
        resetData()
        lastErrorData.chatMessage = enteredCommand
        success = runCommand(enteringPlayer, ChatCommand.commandMap.get(rootCommand), words)
        if( not success )
            //TODO: Run Error Callback
            
    destroy words
    return success



function runCommand( player enteringPlayer, Command originCommand, LinkedList<string> inputs ) returns boolean

    // Command with action (with no sub commands)
    var command = originCommand 

    // Find command
    while( command.subCommands.size() > 0 )
        let input = inputs.dequeue()
        if( input == "" )
            lastErrorData.error = MISSING_SUB_COMMAND
            return false
        command = command.subCommands.get(input)
        if( command == null )
            lastErrorData.error = UNKNOWN_SUB_COMMAND
            lastErrorData.wrongInput = input
            return false

    // Checking Action
    if( command.action == null )
        command.commandError("No subcommand or default action has been given")
        return false

    var success = false

    // Interpreet Arguments
    success = interpretInputArguments(command, inputs)
    if( not success )
        return false

    // Interpreet Arguments
    success = interpretInputOptions(command, inputs)
    if( not success )
        return false

    argumentList.setCommand(command)
    optionList.setCommand(command)

    // Run Action
    command.action.run( enteringPlayer, argumentList, optionList )
    
    // Clean up
    return true



    
function interpretInputArguments( Command command, LinkedList<string> inputs ) returns bool
    
    for argument in command.arguments
        if( argument.isList )
        // List Argument
            var elementCount = 0
            var input = inputs.getFirst()
            while( input != "" and not command.options.has(input) )
                if( (argument.argType == ArgumentType.INT and not input.isInt()) or (argument.argType == ArgumentType.REAL and not input.isReal()) )
                    lastErrorData.error = WRONG_ARG_TYPE
                    lastErrorData.expectedType = argument.argType
                    return false
                argumentList.addArgument(argument.argType, inputs.dequeue())
                elementCount++
                input = inputs.getFirst()

            if( elementCount == 0 )
                lastErrorData.error = MISSING_ARGUMENT
                return false

        else
        // Single Argument
            let input = inputs.getFirst()
            if( input == "" )
                lastErrorData.error = MISSING_ARGUMENT
                return false
            else
                var correctArg = true
                if( argument.argType == ArgumentType.INT and not input.isInt() )
                    correctArg = false
                if( argument.argType == ArgumentType.REAL and not input.isReal() )
                    correctArg = false

                if( correctArg )
                    argumentList.addArgument(argument.argType, inputs.dequeue() )
                else
                    lastErrorData.error = WRONG_ARG_TYPE
                    lastErrorData.expectedType = argument.argType
                    return false            
    return true




function interpretInputOptions(Command command, LinkedList<string> inputs) returns bool
    let options = command.options
    
    for word in inputs

        if( options.has(word) )
        // Switch Option
            let option = options.get(word)
            if( option.argType == NONE )
                optionList.add(option.label, "")
            else
                lastErrorData.error = MISSING_OPTION_ARG
                lastErrorData.expectedType = option.argType
                lastErrorData.option = option.label
                return false
            
        else if( word.length() > 2 and word.contains("=") )
        // Value Option
                    
            var optionLabel = word.substring(0, word.indexOf("="))
            var optionValue = word.substring(word.indexOf("=")+1, word.length())
            var option = options.get(optionLabel)

            // Check if option exists
            if( option == null )
                lastErrorData.error = UNKNOWN_OPTION
                lastErrorData.wrongInput = optionLabel
                return false
            
            // Check Option type
            if( option.argType == NONE or (option.argType == ArgumentType.INT and not optionValue.isInt()) or (option.argType == ArgumentType.REAL and not optionValue.isReal()) )
                lastErrorData.error = WRONG_OPTION_ARG_TYPE
                lastErrorData.expectedType = option.argType
                lastErrorData.option = optionLabel
                return false
            optionList.add(optionLabel, optionValue)

        else
            lastErrorData.error = UNKNOWN_OPTION
            lastErrorData.wrongInput = word
            return false

    return true
                
    
        

class ArgumentList

    protected let values = new LinkedList<string>
    protected let types = new LinkedList<ArgumentType>
    protected Command command = null

    function setCommand(Command command)
        this.command = command

    protected function addArgument(ArgumentType argType, string value)
        types.add(argType)
        values.add(value)

    function getInt() returns int
        if( types.dequeue() != ArgumentType.INT )
            command.commandError("Next argument is not an integer value")
        return values.dequeue().toInt()

    function getReal() returns real
        if( types.dequeue() != ArgumentType.REAL )
            command.commandError("Next argument is not a real value")
        return values.dequeue().toReal()

    function getString() returns string
        if( types.dequeue() != ArgumentType.STRING )
            command.commandError("Next argument is not a real value")
        return values.dequeue()

    function size() returns int
        return values.size()

    function hasNext() returns boolean
        return values.size() > 0

    protected function clear()
        values.clear()
        types.clear()
        command = null


class OptionList

    protected let values = new IterableMap<string, string>
    protected Command command

    function setCommand(Command command)
        this.command = command
    
    function add( string option, string value )
        if(values.has(option))
            values.remove(option)
        values.put(option, value)

    private function getOption(string option) returns Option
        if( not command.options.has(option) )
            command.commandError("Cannot find option {0}".format(option))
        return command.options.get(option)

    function getInt(string option) returns int
        if( getOption(option).argType != INT )
            command.commandError("Option {0} is not an integer value".format(option))
        return values.has(option) ? values.get(option).toInt() : getOption(option).defaultValue.toInt()         

    function getReal(string option) returns real
        if( getOption(option).argType != REAL )
            command.commandError("Option {0} is not a real value".format(option))
        return values.has(option) ? values.get(option).toReal() : getOption(option).defaultValue.toReal()       

    function getString(string option) returns string
        if( getOption(option).argType != STRING )
            command.commandError("Option {0} is not a string value".format(option))
        return values.has(option) ? values.get(option) : getOption(option).defaultValue   
    
    function getBool(string option) returns bool
        if( getOption(option).argType != NONE )
            command.commandError("Option {0} is not a switch (boolean value)".format(option))
        return values.has(option) 
        
    protected function clear()
        values.flush()
        command = null
        

        


// ======================================================================================================================================================
// TESTS

// Custom Test methods -------------

function ArgumentType.assertEquals(ArgumentType expected)
    if this != expected
	    testFail("Expected <" + expected.toString() + ">, Actual <" + this.toString() + ">")

function CommandError.assertEquals(CommandError expected)
    if this != expected
	    testFail("Expected <" + expected.toString() + ">, Actual <" + this.toString() + ">")


// -------------------------------------------------------------------------------------------------

@Test
function overallTest_1()
    
    var cmd = new ChatCommand("-root")
    ..addArgument(ArgumentType.INT)
    ..addArgument(ArgumentType.STRING)
    ..addOptionInt("-o1", 0)
    ..addOptionSwitch("-o2")

    ..setAction() (p, args, opts) ->
        args.getInt().assertEquals(10)
        args.getString().assertEquals("hello")
        opts.getBool("-o2").assertTrue()
    commandEntered(null, "-root 10 hello -o1=20 -o2")

    cmd.setAction() (p, args, opts) ->
        args.getInt().assertEquals(30)
        args.getString().assertEquals("20")
        opts.getBool("-o2").assertFalse()
    commandEntered(null, "-root 30 20 -o1=10")
    
    
    

@Test
function subCommandTest()
    /* Test if sub commands are registered correctly, and correct errors
        are given  */
    var cmd = new ChatCommand("-root")
    cmd.addSubCommand("sub1").setAction( (p, args, opts) -> skip)
    cmd.addSubCommand("sub2").setAction( (p, args, opts) -> skip)

    // Testing correct calls
    assertTrue( commandEntered(null, "-root sub1") )
    lastErrorData.error.assertEquals( CommandError.NONE )
    
    assertTrue( commandEntered(null, "-root sub2") )
    lastErrorData.error.assertEquals( CommandError.NONE )

    // Testing wrong calls
    assertTrue( not commandEntered(null, "-root sub") )
    lastErrorData.error.assertEquals( CommandError.UNKNOWN_SUB_COMMAND )

    assertTrue( not commandEntered(null, "-root sub sub1") )
    lastErrorData.error.assertEquals( CommandError.UNKNOWN_SUB_COMMAND )
    
    assertTrue( not commandEntered(null, "-root") )
    lastErrorData.error.assertEquals( CommandError.MISSING_SUB_COMMAND )



    
@Test
function optionEvaluationTest()

    let cmd = new Command("cmd")
    ..addOptionInt("o1", 10)
    ..addOptionReal("o2", 10.)
    ..addOptionString("o3", "hello")
    ..addOptionSwitch("o4")

    let input = new LinkedList<string>
    resetErrorData()
    optionList.clear()

    // All values correct
    input..clear()..add("o2=0.5", "o1=20", "o4", "o3=nothello" )
    assertTrue(interpretInputOptions(cmd, input))
    optionList.getInt("o1").assertEquals(20)
    optionList.getReal("o2").assertEquals(0.5)
    optionList.getString("o3").assertEquals("nothello")
    optionList.getBool("o4").assertTrue()

    // No values given (testing default values)
    input..clear()
    assertTrue(interpretInputOptions(cmd, input))
    optionList.getInt("o1").assertEquals(10)
    optionList.getReal("o2").assertEquals(10.)
    optionList.getString("o3").assertEquals("hello")
    optionList.getBool("o4").assertFalse()

    // Wrong option argument
    resetData()
    input..clear()..add("o2=0.5","o1=0.6")
    assertTrue(interpretInputOptions(cmd, input))
    lastErrorData.error.assertEquals(CommandError.WRONG_OPTION_ARG_TYPE)

    // Wrong argument for switch (should be none)
    resetData()
    input..clear()..add("o4=10")
    assertTrue(interpretInputOptions(cmd, input))
    lastErrorData.error.assertEquals(CommandError.WRONG_OPTION_ARG_TYPE)

    // Missing Argument Type
    resetData()
    input..clear()..add("o2")
    assertTrue(interpretInputOptions(cmd, input))
    lastErrorData.error.assertEquals(CommandError.MISSING_OPTION_ARG)

    // Double option
    resetData()
    input..clear()..add("o2=10", "o2=100")
    assertTrue(interpretInputOptions(cmd, input))
    optionList.getReal("o2").assertEquals(100)

    // Wrong option 1 
    resetData()
    input..clear()..add("o5=hello")
    assertTrue(interpretInputOptions(cmd, input))
    lastErrorData.error.assertEquals(CommandError.UNKNOWN_OPTION)

    // Wrong option 2
    resetData()
    input..clear()..add("thisisnotanoption")
    assertTrue(interpretInputOptions(cmd, input))
    lastErrorData.error.assertEquals(CommandError.UNKNOWN_OPTION)


@Test
function argumentEvaluationTest_Simple()
    
    let cmd = new Command("cmd")..addArgument( ArgumentType.INT )
    let inputs = new LinkedList<string>
    resetData()

    // Correct
    inputs.add("100")
    assertTrue(interpretInputArguments(cmd, inputs))
    argumentList.getInt().assertEquals(100)

    // Wrong Type
    inputs..clear()..add("hello")
    assertTrue(interpretInputArguments(cmd, inputs))
    assertTrue( lastErrorData.error == CommandError.WRONG_ARG_TYPE )
    assertTrue( lastErrorData.expectedType == ArgumentType.INT)

    // Missing argument
    resetData()
    inputs.clear()
    assertTrue(interpretInputArguments(cmd, inputs))
    lastErrorData.error.assertEquals(CommandError.MISSING_ARGUMENT)
    

@Test
function argumentEvaluationTest_List()
    let cmd = new Command("cmd")..addListArgument( ArgumentType.INT )
    let inputs = new LinkedList<string>
    resetData()
    
    // Correct arguments
    inputs.add("100","200","300","400","500")
    assertTrue(interpretInputArguments(cmd, inputs))
    argumentList.getInt().assertEquals(100)
    argumentList.getInt().assertEquals(200)
    argumentList.getInt().assertEquals(300)
    argumentList.getInt().assertEquals(400)
    argumentList.getInt().assertEquals(500)

    // No arguments
    resetData()
    inputs.clear()
    assertTrue(interpretInputArguments(cmd, inputs))
    lastErrorData.error.assertEquals(CommandError.MISSING_ARGUMENT)

    // Wrong argument type
    resetData()
    inputs.clear()
    inputs.add("100", "200", "300", "hello")
    assertTrue(interpretInputArguments(cmd, inputs))
    lastErrorData.error.assertEquals(CommandError.WRONG_ARG_TYPE)
    

@Test
function argumentEvaluationTest_DoubleArgument()
    

    let cmd = new Command("cmd")
    ..addArgument(ArgumentType.INT )
    ..addArgument(ArgumentType.STRING )
    let inputs = new LinkedList<string>
    resetData()
    
    // Both args
    resetData()
    inputs..clear()..add("100","hello")
    assertTrue(interpretInputArguments(cmd, inputs))
    argumentList.getInt().assertEquals(100)
    argumentList.getString().assertEquals("hello")

    // No args
    resetData()
    inputs.clear()
    assertTrue(interpretInputArguments(cmd, inputs))
    lastErrorData.error.assertEquals(CommandError.MISSING_ARGUMENT)

    // Only first Arg
    resetData()
    inputs..clear()..add("100")
    assertTrue(interpretInputArguments(cmd, inputs))
    lastErrorData.error.assertEquals(CommandError.MISSING_ARGUMENT)

    // Only second arg (error since first is int and second is string)
    resetData()
    inputs..clear()..add("hello")
    assertTrue(interpretInputArguments(cmd, inputs))
    lastErrorData.error.assertEquals(CommandError.WRONG_ARG_TYPE)


    

    

    
    



